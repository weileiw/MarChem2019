%+++++ this script contains two functions,
% function [f,dfdx,d2fdx2] = neglogpost(x,p,grd,M2d) and
% function [M,D] = Pcycle(p,PFD,dPFDdb,dPFDdd,M2d);
% this first function is used to calculated objective function
% value(f), along with gradient(dfdx) and hessian(d2fdx2)
% towards parameters with the output of the second function.
% x is a vector of parameters, p is a
% structure that contains data and constants.M2d is a mask.
function [f,dfdx,d2fdx2,eigV,eigE,M] = neglogpost_eigen(x,p,grd,M2d)

    nip    = length(x);
    d2fdx2 = zeros(nip,nip);
    dx     = sqrt(-1)*eps.^3*eye(nip);
    O = p.O;
    prior =    [-0.11; -0.11;  0.32; 0.32; 0.32; 1.70; 5.00; ...
                2; -6.00; -6.00; 0.46; -6.00; -6.00];
    
    U     = d0([1/0.16; 1/0.16; 1/2.98; 1/2.98; 1/2.98; 1/4.01; 1/6.64; ...
                1/100; 1/100; 1/100; 1/100; 1/100; 1/100]);

    LAMBDA = p.LAMBDA;
    GAMMA  = p.GAMMA;

    % the gradient is calculated analytically.
    % the for loop is used to calculated Hessian matrix by
    % using complex step method.
    for ii = 1:nip
        x    = real(x)+dx(:,ii);
        p.bl  = exp(x(1));
        p.bs  = exp(x(2));
        p.kappa1 = exp(x(3));
        p.kappa2 = exp(x(4));
        p.kappa3 = exp(x(5));
        p.alpha  = exp(x(6));
        p.beta   = exp(x(7));
        p.xPOC   = exp(x(8));
        p.xChl   = exp(x(9));
        p.xPhy   = exp(x(10));
        p.xpoc   = exp(x(11));
        p.xchl   = exp(x(12));
        p.xphy   = exp(x(13));

        [PFDl,dPFDldb,dPFDldbeta] = buildPFD_l(M2d,p,grd);
        [PFDs,dPFDsdb,dPFDsdalpha] = buildPFD_s(M2d,p,grd);

        p.PFDl = PFDl;  p.dPFDldb = dPFDldb; p.dPFDldbeta  = dPFDldbeta;
        p.PFDs = PFDs;  p.dPFDsdb = dPFDsdb; p.dPFDsdalpha = dPFDsdalpha;
        
        [M,G,eigV,eigE] = Pcycle(p,M2d);
        
        ep = (x-prior);
        W = d0([1./(p.POC*0.02).^2;1./(p.poc*0.02).^2; 1./(p.Chl*0.30).^2;...
                1./(p.chl*0.30).^2;1./(p.Phyo*0.30).^2;1./(p.phyo*0.30).^2]);
        
        e = M-O;

        f = 0.5*GAMMA*(e.'*W*e)+0.5*LAMBDA*(ep.'*U*ep);
        
        % dfdx = e.'*W*dedx;
        % dedx = dedC*dCdx;
        % dCdx = dCdp*dpdx;
        dpdx  = diag(exp(x));
        dedx = G*dpdx;
        dfdx = GAMMA*(e.'*W*dedx) + LAMBDA*(ep.'*U);


        dfdx_test(ii) = imag(f)./eps.^3;
        d2fdx2(ii,:)  = imag(dfdx)./eps.^3;
        
    end
    
    f = real(f);
    dfdx = real(dfdx);
    
% function Pcycle output model field (M) and first derivative(D)
function [M,D,eigV,eigE] = Pcycle(p,M2d)

    global GN
    iwet = find(M2d(:));
    nwet = length(iwet);
    I = speye(nwet);

    PFDl = p.PFDl;
    PFDs = p.PFDs;
    dPFDldb = p.dPFDldb;
    dPFDsdb = p.dPFDsdb;
    dPFDldbeta  = p.dPFDldbeta;
    dPFDsdalpha = p.dPFDsdalpha; 
    kappa1 = p.kappa1;
    kappa2 = p.kappa2;
    kappa3 = p.kappa3;
    alpha  = p.alpha;
    beta   = p.beta;
    xPOC   = p.xPOC;
    xChl   = p.xChl;
    xPhy   = p.xPhy;
    xpoc   = p.xpoc;
    xchl   = p.xchl;
    xphy   = p.xphy;

    POC = GN(0*nwet+1:1*nwet);
    poc = GN(1*nwet+1:2*nwet);
    Chl = GN(2*nwet+1:3*nwet);
    chl = GN(3*nwet+1:4*nwet);
    Phy = GN(4*nwet+1:5*nwet);
    phy = GN(5*nwet+1:6*nwet);

    X0 = [POC;poc;Chl;chl;Phy;phy];
    options.atol = 1e-12;
    options.rtol = 1e-12;
    options.iprint = 0;

    [M,ierr] = nsnew(X0,@(X) eqs(X,p,M2d),options);
    GN = 0.999*real(M);

    if (ierr ~=0)
        fprintf('eqNcycle did not converge.\n');
        keyboard
    end

    if nargout>1
        POC = M(0*nwet+1:1*nwet);
        poc = M(1*nwet+1:2*nwet);
        Chl = M(2*nwet+1:3*nwet);
        chl = M(3*nwet+1:4*nwet);
        Phy = M(4*nwet+1:5*nwet);
        phy = M(5*nwet+1:6*nwet);
        
        Z = sparse(nwet,1);
        O = [1;Z(1:end-1)];
        
        dFdbl  = [-dPFDldb*POC;...
                  Z;...
                  -dPFDldb*Chl;...
                  Z;...
                  -dPFDldb*Phy;...
                  Z];
        
        dFdbs = [Z;...
                 -dPFDsdb*poc;...
                 Z;...
                 -dPFDsdb*chl;...
                 Z;...
                 -dPFDsdb*phy];
        
        dFdkappa1 = [Z;...
                     Z;...
                     Z;...
                     -chl;...
                     Z;...
                     chl];
        
        dFdkappa2 = [Z;...
                     -poc;...
                     Z;...
                     Z;...
                     Z;...
                     Z];
        
        dFdkappa3 = [Z;...
                     Z;...
                     Z;...
                     Z;...
                     Z;...
                     -phy];
        
        dFdalpha = [poc.*poc;...
                    -poc.*poc-dPFDsdalpha*poc;...
                    chl.*chl;...
                    -chl.*chl-dPFDsdalpha*chl;...
                    phy.*phy;...
                    -phy.*phy-dPFDsdalpha*phy];
        
        dFdbeta  = [-POC-dPFDldbeta*POC;...
                    POC;...
                    -Chl-dPFDldbeta*Chl;...
                    Chl;...
                    -Phy-dPFDldbeta*Phy;...
                    Phy];
        
        dFdxPOC = [O;...
                   Z;...
                   Z;...
                   Z;...
                   Z;...
                   Z];
        
        dFdxChl = [Z;...
                   Z;...
                   O;...
                   Z;...
                   Z;...
                   Z];

        dFdxPhy = [Z;...
                   Z;...
                   Z;...
                   Z;...
                   O;...
                   Z];

        dFdxpoc = [Z;...
                   O;...
                   Z;...
                   Z;...
                   Z;...
                   Z];
        
        dFdxchl = [Z;...
                   Z;...
                   Z;...
                   O;...
                   Z;...
                   Z];

        dFdxphy = [Z;...
                   Z;...
                   Z;...
                   Z;...
                   Z;...
                   O];
        
        Fx = [dFdbl,...
              dFdbs,...
              dFdkappa1,...
              dFdkappa2,...
              dFdkappa3,...
              dFdalpha,...
              dFdbeta,...
              dFdxPOC,...
              dFdxChl,...
              dFdxPhy,...
              dFdxpoc,...
              dFdxchl,...
              dFdxphy];
        
        % dFdb,...
        Jac = [[-(beta*I+PFDl),      2*alpha*d0(poc), 0*I, 0*I, 0*I, 0*I];...
               [beta*I, -(2*alpha*d0(poc)+kappa2*I+PFDs), 0*I, 0*I, 0*I, 0*I];...
               [0*I, 0*I, -(beta*I+PFDl),      2*alpha*d0(chl), 0*I, 0*I];...
               [0*I, 0*I, beta*I, -(2*alpha*d0(chl)+kappa1*I+PFDs), 0*I, 0*I];...
               [0*I, 0*I, 0*I, 0*I,   -(beta*I+PFDl),    2*alpha*d0(phy)];...
               [0*I, 0*I, 0*I, kappa1*I, beta*I, -(2*alpha*d0(phy)+kappa3*I+PFDs)]];
        
        [eigV,eigE,FLAG] = eig(full(real(-Jac)));
        
        DF = mfactor(Jac);
        
        D = -mfactor(DF,Fx);
    end
    
function [F, DF] = eqs(X,p,M2d)
    
    iwet = find(M2d(:));
    nwet = length(iwet);
    I = speye(nwet);
    
    PFDs = p.PFDs;
    PFDl = p.PFDl;
    kappa1 = p.kappa1;
    kappa2 = p.kappa2;
    kappa3 = p.kappa3;
    alpha  = p.alpha;
    beta   = p.beta;
    xPOC   = p.xPOC;
    xChl   = p.xChl;
    xPhy   = p.xPhy;
    xpoc   = p.xpoc;
    xchl   = p.xchl;
    xphy   = p.xphy;
    
    POC = X(0*nwet+1:1*nwet);
    poc = X(1*nwet+1:2*nwet);
    Chl = X(2*nwet+1:3*nwet);
    chl = X(3*nwet+1:4*nwet);
    Phy = X(4*nwet+1:5*nwet);
    phy = X(5*nwet+1:6*nwet);

    fPOC = [xPOC;zeros(nwet-1,1)];
    fChl = [xChl;zeros(nwet-1,1)];
    fPhy = [xPhy;zeros(nwet-1,1)];

    fpoc = [xpoc;zeros(nwet-1,1)];
    fchl = [xchl;zeros(nwet-1,1)];
    fphy = [xphy;zeros(nwet-1,1)];

    F = [[alpha*poc.*poc-beta*POC-PFDl*POC+fPOC];...
         [beta*POC-alpha*poc.*poc-kappa2*poc-PFDs*poc+fpoc];...
         [alpha*chl.*chl-beta*Chl-PFDl*Chl+fChl];...
         [beta*Chl-alpha*chl.*chl-kappa1*chl-PFDs*chl+fchl];...
         [alpha*phy.*phy-beta*Phy-PFDl*Phy+fPhy];...
         [beta*Phy+kappa1*chl-alpha*phy.*phy-kappa3*phy-PFDs*phy+fphy]];

    if nargout > 1

     Jac = [[-(beta*I+PFDl),      2*alpha*d0(poc), 0*I, 0*I, 0*I, 0*I];...
            [beta*I, -(2*alpha*d0(poc)+kappa2*I+PFDs), 0*I, 0*I, 0*I, 0*I];...
            [0*I, 0*I, -(beta*I+PFDl),      2*alpha*d0(chl), 0*I, 0*I];...
            [0*I, 0*I, beta*I, -(2*alpha*d0(chl)+kappa1*I+PFDs), 0*I, 0*I];...
            [0*I, 0*I, 0*I, 0*I,   -(beta*I+PFDl),    2*alpha*d0(phy)];...
            [0*I, 0*I, 0*I, kappa1*I, beta*I, -(2*alpha*d0(phy)+kappa3*I+PFDs)]];

      DF = mfactor(Jac);

    end
